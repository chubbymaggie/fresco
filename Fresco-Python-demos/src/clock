#!/usr/bin/env python
# Python Berlin client that implements a client-side Graphic
# Copyright (c) 2000 by Stephen Davies
# This file is licensed for use under the GPL.
#
# Tabstop is 8, SoftTabStop is 4, ShiftWidth is 4 (as per last line)
#

import sys, string, time, math, thread
from omniORB import CORBA

# Import berlin client lib
import berlin
from berlin import Label, Callback, nullAny

# Import the Warsaw stubs
import Warsaw, Unidraw
import Warsaw__POA

# Import Warsaw lib
import pywarsaw

class TickGraphic (pywarsaw.PyGraphic):
    "Simple graphic that draws a 'tick'"
    def request(self): # --> void
	x = Warsaw.Graphic.Requirement(1, 2000., 3000., 100., 0.)
	y = Warsaw.Graphic.Requirement(1, 2000., 3000., 100., 0.)
	z = Warsaw.Graphic.Requirement(1, 0., 0., 0., 0.)
	req = Warsaw.Graphic.Requisition(x, y, z, 0)
	return req
    def draw(self, drawTraversal):
	dk = drawTraversal.drawing()
	#print "dk is: ", dk
	transform = drawTraversal.current_transformation()
	region = drawTraversal.current_allocation()
	bounds_lower, bounds_upper = region.bounds()
	dk.save()
	dk._set_transformation(transform)
	# Draw background
	dk._set_foreground(Warsaw.Color(0.9, 0.9, 0.9, 1.0))
	dk._set_surface_fillstyle(Warsaw.DrawingKit.solid)
	dk.draw_rectangle(bounds_lower, bounds_upper)
	# Draw tick
	bounds_delta = (bounds_upper.x - bounds_lower.x,
	    bounds_upper.y - bounds_lower.y)
	def scale(point, low=bounds_lower, delta = bounds_delta):
	    return Warsaw.Vertex(point[0] * delta[0] + low.x, point[1] * delta[1] + low.y, low.z)
	path = map(scale, [(.2,.6),(.4,.7),(.9,.1),(.4,.8),(.2,.6)])
	dk._set_foreground(Warsaw.Color(0.2, 0.9, 0.9, 1.0))
	dk.draw_path(path)
	dk.restore()


class ClockGraphic (pywarsaw.PyGraphic):
    "Simple graphic that draws a clock"
    def __init__(self):
	pywarsaw.PyGraphic.__init__(self)
	thread.start_new_thread(self._run_update_thread, ())
    def _run_update_thread(self):
	# FIXME: calibrate
	while 1:
	    time.sleep(1)
	    self.need_redraw()
    def request(self): # --> void
	x = Warsaw.Graphic.Requirement(1, 2000., 3000., 100., 0.)
	y = Warsaw.Graphic.Requirement(1, 2000., 3000., 100., 0.)
	z = Warsaw.Graphic.Requirement(1, 0., 0., 0., 0.)
	req = Warsaw.Graphic.Requisition(x, y, z, 0)
	return req
    def draw(self, drawTraversal):
	dk = drawTraversal.drawing()
	transform = drawTraversal.current_transformation()
	region = drawTraversal.current_allocation()
	# Some useful numbers
	bounds_lower, bounds_upper = region.bounds()
	bounds_delta = (bounds_upper.x - bounds_lower.x,
	    bounds_upper.y - bounds_lower.y)
	bounds_middle = Warsaw.Vertex((bounds_upper.x + bounds_lower.x)/2,
	    (bounds_upper.y + bounds_lower.y)/2, 0)
	bounds_halfdelta = (bounds_delta[0]/2, bounds_delta[1]/2)
	dk.save()
	dk._set_transformation(transform)
	def scale(point, mid=bounds_middle, delta = bounds_halfdelta):
	    "Scales a normalised vector [-1:1] to the whole graphic"
	    return Warsaw.Vertex(point[0] * delta[0] + mid.x, point[1] * delta[1] + mid.y, mid.z)
	def rotate(angle, path):
	    "Rotates all elements in the path by angle radians"
	    m = (( math.cos(angle),-math.sin(angle)),
		 ( math.sin(angle), math.cos(angle)))
	    ret = []
	    for x,y in path:
		ret.append( (x*m[0][0]+y*m[0][1], x*m[1][0]+y*m[1][1]) )
	    return ret
	# Draw background first
	dk._set_foreground(Warsaw.Color(0.9, 0.9, 0.9, 1.0))
	dk._set_surface_fillstyle(Warsaw.DrawingKit.solid)
	dk.draw_rectangle(bounds_lower, bounds_upper)
	# Draw hour-ticks
	path = [(-.05,-.8),(.05,-.8),(.05,-.7),(-.05,-.7),(-.05,-.8)]
	dk._set_foreground(Warsaw.Color(0.2, 0.3, 0.5, 1.0))
	circle = math.pi*2
	for i in range(12):
	    dk.draw_path(map(scale, rotate(i*circle/12, path)))
	# Get time
	times = time.localtime(time.time())
	hours, mins, secs = times[3], times[4], times[5]
	# Hours
	path = [(-.03,.03),(0,-.6),(.03,.03),(-.03,.03)]
	dk.draw_path(map(scale, rotate(hours*circle/12, path)))
	# Minutes
	path = [(-.02,.02),(0,-.8),(.02,.02),(-.02,.02)]
	dk.draw_path(map(scale, rotate(mins*circle/60, path)))
	# Hours
	path = [(-.01,.01),(0,-.95),(.01,.01),(-.01,.01)]
	dk.draw_path(map(scale, rotate(secs*circle/60, path)))
	dk.restore()

class GraphicApp (berlin.App):
    def run(self):
	graphic = ClockGraphic()._this()

	self.window = kits.desktop.shell(kits.tool.group(graphic))

	kits.desktop.shell(kits.tool.group(TickGraphic()._this()))


def main():
    # Create singletons
    global app, kits, connection
    connection = berlin.get_connection()
    kits = berlin.get_kits()
    app = GraphicApp()

    app.run()

    # Wait for the quit event
    app.quit.wait()

    # Tell the orb to shutdown (and wait for pending calls to complete)
    connection.orb.shutdown(1)

if __name__ == '__main__':
    main()

# vim: ts=8:sts=4:sw=4
