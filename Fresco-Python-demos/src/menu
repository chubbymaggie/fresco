#!/usr/bin/env python
# Python Berlin client that implements a client-side menu
# Copyright (c) 2000 by Stephen Davies
# This file is licensed for use under the GPL.
#
# Tabstop is 8, SoftTabStop is 4, ShiftWidth is 4 (as per last line)
#
# Note that the menu api implemented here resembles more traditional
# state-heavy guis, rather than berlin's lightweight graphic model.
# Disclaimer: This is just an experiment :)

import sys, string
from omniORB import CORBA

# Import the Warsaw stubs
import Warsaw, Unidraw
import Warsaw__POA

# Define an implementation of the ClientContext interface
class ClientContextImpl (Warsaw__POA.ClientContext):
    def userName(self): return US("joe")
    def ping(self): return

def US(s):
    "Convert the given python string to a Unistring"
    return map(lambda x:ord(x), s)

# The default kits available. More can be added using kits.add_kit()
# TODO: include version and property information in the tuple
_defaultKitNames = {
    'tool'    : ('Warsaw',  'ToolKit'),
    'image'   : ('Warsaw',  'ImageKit'),
    'figure'  : ('Warsaw',  'FigureKit'),
    'desktop' : ('Warsaw',  'DesktopKit'),
    'layout'  : ('Warsaw',  'LayoutKit'),
    'text'    : ('Warsaw',  'TextKit'),
    'unidraw' : ('Unidraw', 'UnidrawKit'),
}

# An empty Any object for sending to Commands
nullAny = CORBA.Any(CORBA.TC_null, None)
    
class Kits:
    """This class resolves kits upon request, and caches the resolved kit
    objects. It loads _defaultKitNames as the default set of kits, but more
    can be added using the add_kit method."""
    def __init__(self):
	"""Initialise the Kits singleton, and insert it into the global
	(module) namespace"""
	global kits
	kits = self
	self._kitNames = {}
	self._kitNames.update(_defaultKitNames)
	self._kitObjects = {}

    def add_kit(name, module, kit):
	self._kitNames[name] = (module, kit)

    def __getattr__(self, kit):
	# Check cache
	if self._kitObjects.has_key(kit):
	    return self._kitObjects[kit]
	# Try and resolve
	if self._kitNames.has_key(kit):
	    # Find and resolve the kit
	    module, name = self._kitNames[kit]
	    idl = "IDL:%s/%s:1.0"%self._kitNames[kit]
	    obj = connection.context.resolve(idl, [])
	    cls = globals()[module].__dict__[name]
	    obj = obj._narrow(cls)
	    if obj is not None:
		self._kitObjects[kit] = obj
		return obj
	# FIXME -- what happens here to signal bad attr?

class Connection:
    """Connection wrapper that does all the CORBA stuff"""
    def __init__(self, clientContext=None):
	"""Initialises the singleton, inserts it into the global (module)
	namespace, and finds the Berlin server. You may pass your own
	ClientContext object (not CORBA var!), else a ClientContextImpl will
	be used."""
	global connection
	connection = self
	# Import the CORBA module
	import CosNaming
	# Initialise the ORB
	self.orb = CORBA.ORB_init(sys.argv, CORBA.ORB_ID)

	# Find the POA
	self.poa = self.orb.resolve_initial_references("RootPOA")
	# Activate the POA
	self.poaManager = self.poa._get_the_POAManager()
	self.poaManager.activate()

	# Create an ClientContext
	if clientContext is None: clientContext = ClientContextImpl()
	# Create an object reference, and implicitly activate the object
	print "clientContext is",clientContext
	self.clientContext = clientContext._this()

	# get a server context
	object = self.orb.resolve_initial_references("NameService")
	context = object._narrow(CosNaming.NamingContext)
	name = [CosNaming.NameComponent("IDL:Warsaw/Server:1.0", "Object")]
	object = context.resolve(name)
	self.server = object._narrow(Warsaw.Server)
	print "Got server:",self.server
	print "Client context is:",self.clientContext
	self.context  = self.server.create_server_context(self.clientContext)

def Label(string):
    "Creates a black label from the given string"
    return kits.tool.rgb(kits.text.chunk(US(string)),0.,0.,0.)

class Callback(Warsaw__POA.Command):
    """Small wrapper command which calls a python function with a single
    argument which is the Any."""
    def __init__(self, callback):
	self.callback = callback
    def execute(self, any):
	print "Callback to",self.callback,"with",any
	self.callback(any)

class MenuItem:
    """Encapsulates a Menu item with label and optional submenu and callback.
    TODO: provide api to close all parent popups once an item is selected."""
    def __init__(self, label, submenu=None, callback=None):
	self.label = label
	self.submenu = submenu
	self.callback = callback
	if (self.submenu is not None):
	    self.submenu.parent_item = self
	self.callback_command = None
	self.graphic = None

    def get_command(self):
	"Returns the cached CORBA callback command"
	if self.callback_command is None:
	    self.callback_command = Callback(self.clicked)._this()
	return self.callback_command

    def get_graphic(self):
	"Returns or creates the controller/graphic for this item"
	if self.graphic is None:
	    button = kits.tool.button(Label(self.label), self.get_command())
	    self.graphic = kits.layout.margin(button, 20.)
	return self.graphic

    def clicked(self, any):
	# Call callback
	if self.callback is not None:
	    print "callback:",self.callback
	    dir(self.callback)
	    self.callback(any)
	any = CORBA.Any(CORBA.TC_null, None)
	# Show submenu
	if self.submenu is not None:
	    sub = self.submenu.get_graphic()
	    kits.desktop.map(sub, 1).execute(any)
	# Else close this menu and all parents
	else:
	    menu = self.parent_menu
	    while menu is not None:
		kits.desktop.map(menu.get_graphic(), 0).execute(nullAny)
		menu = menu.parent_item
		if menu is not None:
		    menu = menu.parent_menu
		if isinstance(menu, MenuBar):
		    break # stop while at menubar
		    

class Menu:
    """Encapsulates a vertical menu of MenuItems"""
    def __init__(self, items):
	"Creates menu from sequence of items"
	self.items = items
	self.graphic = None
	self.parent_item = None
	for item in items:
	    item.parent_menu = self

    def _get_box(self):
	"""Template method to return the box to put the items in. Defaults to
	vbox"""
	return kits.layout.vbox()

    def get_graphic(self):
	"""Returns or creates the controller/graphic for this Menu"""
	if self.graphic is None:
	    # Create menu
	    box = self._get_box()
	    fspec = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.5)
	    frame = kits.tool.frame(box, 20.0, fspec, 1)

	    for item in self.items:
		box.append_graphic(item.get_graphic())
	    
	    group = kits.tool.group(frame)
	    self.graphic = kits.desktop.transient(group)
	return self.graphic

class MenuBar(Menu):
    """Subclasses Menu to provide a HORIZONTAL menu bar"""
    def _get_box(self):
	"""Overridden template method that returns a hbox instead"""
	return kits.layout.hbox()

class MenuApp:
    def __init__(self):
	global app
	app = self
	Connection()
	Kits()

    def run(self):
	menu = MenuBar([
	    MenuItem('File', submenu=Menu([
		MenuItem('New', submenu=Menu([
		    MenuItem('One'),
		    MenuItem('Two'),
		    MenuItem('Three'),
		])),
		MenuItem('Open...'),
		MenuItem('Close'),
		MenuItem('Quit', callback=self.exit),
	    ])),
	    MenuItem('Help', submenu=Menu([
		MenuItem('Contents'),
		MenuItem('About'),
	    ])),
	])

	vbox = kits.layout.vbox()
	vbox.append_graphic(menu.get_graphic())
	vbox.append_graphic(kits.layout.fixed_size(None,3000.,2000.))

	self.window = vbox
	kits.desktop.map(self.window, 1).execute(nullAny)

    def exit(self, any):
	kits.desktop.map(self.window, 0).execute(nullAny)
	sys.exit(0)


def main():
    # Create singletons
    Connection()
    MenuApp()
    Kits()

    app.run()

    print "Hit ENTER to quit."
    while 1:
   	line = sys.stdin.readline()
   	if len(line) == 1: break

if __name__ == '__main__':
    main()

# vim: ts=8:sts=4:sw=4
