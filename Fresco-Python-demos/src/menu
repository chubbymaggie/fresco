#!/usr/bin/env python
# Python Berlin client that implements a client-side menu
# Copyright (c) 2000 by Stephen Davies
# This file is licensed for use under the GPL.
#
# Tabstop is 8, SoftTabStop is 4, ShiftWidth is 4 (as per last line)
#
# Note that the menu api implemented here resembles more traditional
# state-heavy guis, rather than berlin's lightweight graphic model.
# Disclaimer: This is just an experiment :)

import sys, string, os
from omniORB import CORBA, PortableServer

# Import Berlin module
import berlin
from berlin import Label, Callback, nullAny

# Import the Warsaw stubs
import Warsaw, Unidraw, Layout
import Warsaw__POA

# Import Python client lib
import pywarsaw

class MenuKitImpl (Warsaw__POA.MenuKit):
    """Pretend kit that builds menu objects"""
    def menu_bar(self):
	"""Returns a menubar object"""
	return MenuBar()._this()
    def menu_popup(self):
	"""Returns a menu object"""
	return Menu()._this()
    def menu_item(self, label, callback):
	return MenuItem(label, None, callback)._this()
    def submenu_item(self, label, submenu):
	return MenuItem(label, submenu)._this()

def get_local(object_var, class_obj):
    """Returns the local python object of 'object_var' if it is an instance of
    class_obj, otherwise throws an exception"""
    obj = PortableServer._rootPOA.reference_to_servant(object_var)
    if not isinstance(obj, class_obj): raise TypeError, "Not local object"
    return obj

class MenuItem (Warsaw__POA.MenuItem, pywarsaw.PyController):
    """Encapsulates a Menu item with label and optional submenu and callback.
    TODO: provide api to close all parent popups once an item is selected."""
    def __init__(self, label, submenu=None, callback=None):
	pywarsaw.PyController.__init__(self, 0)
	self.label = label
	self.submenu = submenu
	self.callback = callback
	if (self.submenu):
	    # Submenu must be a local Menu object
	    self.submenu = get_local(self.submenu, Menu)
	    self.submenu.parent_item = self
	self.callback_command = None
	self.__parent_menu = None
	self.__orientation = 0

	# Construct the graphics to display this item
	self.glabel = self.label #Label(self.label)
	#self.label = kits.layout.hmargin_lr_flexible(label,
	#    20., 0., 0., 20., 1000., 0.)
	self.button = self.glabel

	# Construct the dynamic frame that shows when in focus or not
	fspec_out = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.5)
	fspec_none = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.none, 1.0)
	self.frame = kits.tool.dynamic(self.button, 10.,
	    Warsaw.MenuItem.hover, fspec_out, fspec_none, 
	    0, self._this())
	self._set_body(self.frame)

    def _set_parent_menu(self, parent):
	self.__parent_menu = parent

    def _get_parent_menu(self):
	return self.__parent_menu

    def _set_orientation(self, orientation):
	"0 means show below, 1 means show right"
	self.__orientation = orientation
	if orientation:
	    self.button = kits.layout.hbox_align_elements(0.)
	    self.button.append_graphic(self.glabel)
	    self.button.append_graphic(kits.layout.hfill())
	    if self.submenu:
		fspec_focus = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.8)
		fspec_none = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.3)
		tri = kits.tool.dynamic_triangle(None,
		    10., Warsaw.MenuItem.hover, fspec_focus, fspec_none,
		    1, Warsaw.ToolKit.right, self._this())
		tri = kits.layout.fixed_size(tri, 140., 140.)
		tri = kits.layout.margin(tri, 30.)
		self.button.append_graphic(tri)
	    self.frame._set_body(self.button)

    def get_command(self):
	"Returns the cached CORBA callback command"
	if self.callback_command is None:
	    self.callback_command = Callback(self.clicked)._this()
	return self.callback_command

    def _should_open(self):
	"""Returns true if the menu should open.. ie: if some parent menu has an
	active menu already"""
	if not self.submenu: return 0
	item = self
	while item:
	    menu = item._get_parent_menu()
	    current_submenu = menu._current_submenu
	    if current_submenu and current_submenu.test(Warsaw.MenuItem.active):
		return 1
	    item = menu.parent_item
	return 0
    def receive_focus(self, focus):
	self.set(Warsaw.MenuItem.hover)
	if self._should_open():
	    # Steal active state from current menu
	    self.show_submenu()
	else:
	    # Just become the current
	    self.__parent_menu.set_active_submenu(self)
	return pywarsaw.PyController.receive_focus(self, focus)
    def lose_focus(self, device):
	if not self.test(Warsaw.MenuItem.active): self.clear(Warsaw.MenuItem.hover)
	pywarsaw.PyController.lose_focus(self, device)
    def press(self, traversal, event):
	try:
	    # Call callback
	    if self.callback is not None:
		dir(self.callback)
		self.callback.execute(nullAny)
	    # Show submenu
	    if self.submenu is not None:
		self.show_submenu()
		# Else close this menu and all parents
	    else: self.cascade_close_up()
	except:
	    print "An error occurred somewhere in clicked()"
	    import traceback
	    traceback.print_exc()
	    self.cascade_close_up()
    def get_alloc(self):
	alloc = pywarsaw.PyAllocation()
	self.allocations(alloc._this())
	info = alloc.get(0) # controller only has one parent
	region = pywarsaw.PyRegion()
	self.extension(info, region._this())
	return region

    def show_submenu(self):
	region = self.get_alloc()
	self.set(Warsaw.MenuItem.active)
	sub = self.submenu.get_pulldown()
	self.__parent_menu.set_active_submenu(self)
	# Move to right place
	lower, upper = region.bounds()
	if self.__orientation:to = Warsaw.Vertex(upper.x, lower.y, 0.)
	else: to = Warsaw.Vertex(lower.x, upper.y, 0.)
	pos = sub._get_position()
	pos.x = to.x-pos.x; pos.y = to.y-pos.y
	# Do the move, and map
	any = CORBA.Any(Warsaw._tc_Vertex, pos)
	kits.desktop.move(sub).execute(any)
	kits.desktop.map(sub, 1).execute(nullAny)

    def cascade_close_down(self):
	if self.test(Warsaw.MenuItem.active):
	    self.clear(Warsaw.MenuItem.active)
	    self.clear(Warsaw.MenuItem.hover)
	    self.submenu.cascade_close_down()
    def cascade_close_up(self):
	self.cascade_close_down()
	self._get_parent_menu().cascade_close_up()

class Menu (Warsaw__POA.Menu, pywarsaw.PyController):
    """Encapsulates a vertical menu of MenuItems"""
    def __init__(self):
	"Creates menu from sequence of items"
	pywarsaw.PyController.__init__(self, 1)
	self.items = []
	self.graphic = None
	self.pulldown = None
	self.parent_item = None
	self._current_submenu = None
	
	self._init()
    
    def receive_focus(self, focus):
	return pywarsaw.PyController.receive_focus(self, focus)
    def lose_focus(self, device):
	pywarsaw.PyController.lose_focus(self, device)
    def append_item(self, item):
	item = get_local(item, MenuItem)
	self.items.append(item)
	self._add_item(item)
    def _add_item(self, item):
	item._set_parent_menu(self)
	item._set_orientation(1)
	self.box.append_graphic(item._this())
	self.append_controller(item._this())


    def _init(self):
	"""Returns or creates the controller/graphic for this Menu"""
	# Create menu
	self.box = kits.layout.vbox()
	self._set_body(self.box)
	#fspec = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.2)
	#frame = kits.tool.frame(box, 10.0, fspec, 1)

	map(self._add_item, self.items)

    def set_active_submenu(self, item):
	"""Hides any submenu currently open and sets the given as open"""
	if item is self._current_submenu: return
	if self._current_submenu:
	    self._current_submenu.cascade_close_down()
	self._current_submenu = item
    def cascade_close_down(self):
	"""Close this menu and any active submenu"""
	self.set_active_submenu(None)
	kits.desktop.map(self.get_pulldown(), 0).execute(nullAny)
    def cascade_close_up(self):
	"""Close this menu and all parents"""
	self.cascade_close_down()
	self.parent_item.cascade_close_up()
    def get_pulldown(self):
	"""Returns a top-level pulldown graphic for this Menu"""
	if self.pulldown is None:
	    self.pulldown = kits.desktop.pulldown(self._this())
	return self.pulldown

class MenuBar(Menu):
    """Subclasses Menu to provide a HORIZONTAL menu bar"""
    def _add_item(self, item):
	item._set_parent_menu(self)
	self.box.append_graphic(self.hspace)
	self.box.append_graphic(item._this())
	self.append_controller(item._this())
    def _init(self):
	"""Returns or creates the controller/graphic for this Menu"""
	# Create menu
	self.box = kits.layout.hbox_align_elements(0.)

	self.hspace = kits.layout.hspace(80.)
	map(self._add_item, self.items)
	
	spacer_box = kits.layout.hbox()
	spacer_box.append_graphic(self.box)
	spacer_box.append_graphic(kits.layout.hfill())

	fspec = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.outset, 0.2)
	frame = kits.tool.frame(spacer_box, 10.0, fspec, 1)
	
	self._set_body(frame)
    def cascade_close_up(self):
	"""Terminate the cascade traversal"""
	pass


class About:
    text = ["MenuTest","A test of client-side menus","Copyright (c) 2001 by Stephen Davies"]
    def __init__(self):
	"Creates the about box but doesn't map it"
	self.vbox = kits.layout.vbox_align_elements(0.5)
	for line in self.text: 
	    self.vbox.append_graphic(Label(line))
	self.button = kits.widget.button(Label("Okay"), self._get_hide_cmd())
	self.vbox.append_graphic(self.button)
	fspec = Warsaw.ToolKit.FrameSpec(Warsaw.ToolKit.none, 0)
	self.frame = kits.tool.frame(self.vbox, 0.0, fspec, 1)
	self.group = kits.tool.group(kits.tool.rgb(self.frame, 0.8, 0.8, 0.8))
	self.window = kits.desktop.transient(self.group)
	self._mapper_show = kits.desktop.map(self.window, 1)
	self._mapper_hide = kits.desktop.map(self.window, 0)

    def _get_hide_cmd(self):
	class HideCommand (Warsaw__POA.Command):
	    def __init__(self, about): self.about = about
	    def execute(self, any): self.about._mapper_hide.execute(any)
	return HideCommand(self)._this()

    def cb_show(self, any):
	self._mapper_show.execute(any)

class RunApp(Warsaw__POA.Command):
    """Small wrapper command which calls a python function with a single
    argument which is the Any."""
    def __init__(self, command, *args):
	self.command = command
	self.args = (command,)+args
    def execute(self, any):
	print "Running",self.command, self.args
	if os.fork() == 0:
	    os.execvp(self.command, self.args)
	    print "Failed"
	    sys.exit(0)

class MenuApp (berlin.App):
    def run(self):
	def add(menu, items): 
	    for item in items: 
		menu.append_item(item)
	    return menu
	kit = MenuKitImpl()._this()
	
	menu = add(kit.menu_bar(), [
	    kit.submenu_item(Label('Test'), add(kit.menu_popup(), [
		kit.submenu_item(Label('New'), add(kit.menu_popup(), [
		    kit.menu_item(Label('One'), None),
		    kit.menu_item(Label('Two'), None),
		    kit.menu_item(Label('Three'), None),
		])),
		kit.submenu_item(Label('Submenu'), add(kit.menu_popup(), [
		    kit.menu_item(Label('One'), None),
		    kit.menu_item(Label('Two'), None),
		    kit.menu_item(Label('Three'), None),
		])),
		kit.menu_item(Label('Open...'), None),
		kit.menu_item(Label('Close'), None),
		kit.menu_item(Label('Quit'), Callback(self.exit)._this()),
	    ])),
	    kit.submenu_item(Label('Clients'), add(kit.menu_popup(), [
		kit.submenu_item(Label('C++'), add(kit.menu_popup(), [
		    kit.menu_item(Label('demo'), RunApp('demo')._this()),
		    kit.menu_item(Label('canvas'), RunApp('canvas','-r','ggi-dots')._this()),
		])),
		kit.submenu_item(Label('Python'), add(kit.menu_popup(), [
		    kit.menu_item(Label('demo'), RunApp('demo.py')._this()),
		    kit.menu_item(Label('transform'), RunApp('transform.py')._this()),
		    kit.menu_item(Label('clock'), RunApp('graphictest')._this()),
		])),
	    ])),
	    kit.submenu_item(Label('Help'), add(kit.menu_popup(), [
		kit.menu_item(Label('Contents'), None),
		kit.menu_item(Label('About'), Callback(About().cb_show)._this()),
	    ])),
	])

	vbox = kits.layout.vbox()
	vbox.append_graphic(menu)
	contents = kits.figure.pixmap(kits.image.create("marble.png"))
	grid = kits.layout.fixed_grid(Layout.Grid.Index(5,4))
	for i in range(5*4):
	    grid.append_graphic(contents)
	vbox.append_graphic(kits.layout.fixed_size(grid,6400.,4800.))

	self.window = kits.desktop.shell(kits.tool.group(vbox))
	pos = self.window._get_position()
	pos.x = -pos.x; pos.y = -pos.y-210.
	kits.desktop.move(self.window).execute(CORBA.Any(Warsaw._tc_Vertex, pos))
	#pos.x = 6400.; pos.y = 4800.
	#kits.desktop.resize(self.window).execute(CORBA.Any(Warsaw._tc_Vertex, pos))
	#kits.desktop.map(self.window, 1).execute(nullAny)

    def exit(self, any):
	app.quit.set()


def main():
    # Create the singletons
    global app, kits, connection
    connection = berlin.get_connection()
    kits = berlin.get_kits()
    app = MenuApp()

    app.run()

    # Wait for the quit event
    app.quit.wait()

    # Tell the orb to shutdown (and wait for pending calls to complete)
    connection.orb.shutdown(1)

if __name__ == '__main__':
    main()

# vim: ts=8:sts=4:sw=4
