/*$Id$
 *
 * This source file is a part of the Berlin Project.
 * Copyright (C) 1998 Graydon Hoare <graydon@pobox.com> 
 * Copyright (C) 2000 Stefan Seefeld <stefan@berlin-consortium.org> 
 * http://www.berlin-consortium.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
 * MA 02139, USA.
 */

#include "Warsaw/config.hh"
#include "Warsaw/ClientContext.hh"
#include "Berlin/ServerContextImpl.hh"
#include "Berlin/ServerImpl.hh"
#include "Berlin/KitImpl.hh"
#include "Berlin/Logger.hh"
#include "Prague/Sys/Plugin.hh"
#include "Prague/Sys/Directory.hh"

using namespace Prague;

// this is the thing which holds all the references to things a client allocates
// (for garbage collection), does security checks for new allocation, and
// occasionally pings the client to make sure it's still there.

ServerContextImpl::ServerContextImpl(ServerImpl *s, ClientContext_ptr c)
  : server(s), cContext(ClientContext::_duplicate(c)) 
{}

ServerContextImpl::~ServerContextImpl() {}
ClientContext_ptr ServerContextImpl::client() { return ClientContext::_duplicate(cContext);}

// will fill the rest of these in as needs arise. They should do something reasonably obvious.

void ServerContextImpl::setSingleton(const char *name, CORBA::Object_ptr singleton) 
  throw (SecurityException, SingletonFailureException)
{
  server->setSingleton(name, singleton);
}

void ServerContextImpl::delSingleton(const char *name) 
  throw (SecurityException, SingletonFailureException)
{
  server->delSingleton(name);
}

CORBA::Object_ptr ServerContextImpl::getSingleton(const char *name) 
  throw (SecurityException, SingletonFailureException)
{
  return server->getSingleton(name);
}

// this method should eventually do some kind of checking on the
// ClientContext to make sure they are allowed to construct objects on
// this server.

Kit_ptr ServerContextImpl::resolve(const char *type, const Kit::PropertySeq &properties)    
  throw (SecurityException, CreationFailureException)
{
  /*
   * look for loaded kits first
   */
  klist_t::iterator k1 = kits.lower_bound(type), k2 = kits.upper_bound(type);
  for (klist_t::iterator i = k1; i != k2; i++)
    if ((*i).second->supports(properties))
      {
	(*i).second->increment();
	return (*i).second->_this();
      }
  /*
   * now try the factories
   */
  KitImpl *kit = server->create(type, properties);
  if (!kit) throw CreationFailureException();
  kit->bind(ServerContext_var(_this()));
  kit->increment();
  kits.insert(klist_t::value_type(type, kit));
  return kit->_this();
}

// this will nuke all allocated objects if the client has died, and then tell the caller 
// (Server) who will most likely destroy this ServerContext.

bool ServerContextImpl::ping()
{
  MutexGuard guard (mutex);
  bool alive = true;
  try
    {
      if (CORBA::is_nil(cContext)) alive = false;
      else cContext->ping();
    }
  catch (...)
    {
      alive = false;
    }
  if (!alive)
    for(klist_t::iterator i = kits.begin(); i != kits.end(); i++)
      {
//	(*i).second->_dispose();
	kits.erase(i);
      }
  return alive;
}
