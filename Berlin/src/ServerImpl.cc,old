/*$Id$
 *
 * This source file is a part of the Berlin Project.
 * Copyright (C) 1998 Graydon Hoare <graydon@pobox.com> 
 * Copyright (C) 2000 Stefan Seefeld <stefan@berlin-consortium.org> 
 * http://www.berlin-consortium.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
 * MA 02139, USA.
 */
#include "Berlin/ImplVar.hh"
#include "Berlin/ServerImpl.hh"
#include "Berlin/ServerContextImpl.hh"
#include "Berlin/Logger.hh"
#include <Prague/Sys/Tracer.hh>
#include <Prague/Sys/Directory.hh>

using namespace Prague;
using namespace Warsaw;

ServerImpl::ServerImpl() : thread(&ServerImpl::run, this) {}
//. this is the 1 object you *can* find through nameservice. since nameservice has
//. no pretense of having security, we take over and handle security manually
//. once you've found the server. It allocates contexts. It's pretty simple.

ServerContext_ptr ServerImpl::create_server_context(ClientContext_ptr c) throw (SecurityException)
{
  MutexGuard guard (mutex);
  Impl_var<ServerContextImpl> sc(new ServerContextImpl(this, c));
  contexts.push_back(sc);
  return sc._retn()->_this();
}

void ServerImpl::set_singleton(const char *name, CORBA::Object_ptr singleton) 
  throw (SecurityException, SingletonFailureException)
{
  MutexGuard guard (mutex);
  singletons[name] = singleton;
}

void ServerImpl::remove_singleton(const char *name) 
  throw (SecurityException, SingletonFailureException)
{
  MutexGuard guard (mutex);
  smap_t::iterator p = singletons.find(name);
  if (p != singletons.end()) singletons.erase(p);
}

CORBA::Object_ptr ServerImpl::get_singleton(const char *name) 
  throw (SecurityException, SingletonFailureException)
{
  MutexGuard guard (mutex);
  smap_t::iterator p = singletons.find(name);
  if (p != singletons.end()) return CORBA::Object::_duplicate(p->second);
  throw SingletonFailureException();
}

void ServerImpl::ping()
{
  Trace trace("ServerImpl::ping");
  MutexGuard guard (mutex);
  clist_t tmp;
  for (clist_t::iterator i = contexts.begin(); i != contexts.end(); i++)
    {
      if ((*i)->ping()) tmp.push_back(*i);	    
      else
	{
	  Trace trace("ServerContext cleanup");
	  PortableServer::POA_var poa = (*i)->_default_POA();
	  PortableServer::ObjectId *oid = poa->servant_to_id(*i);
	  try
	    {
	      poa->deactivate_object(*oid);
	    }
	  catch(...)
	    {
	      cout << "trouble deactivating the server context..." << endl;
	    }
	  delete oid;
	}
    }
  contexts = tmp;
};

void ServerImpl::scan(const string &name)
{
  MutexGuard guard(mutex);
  /*
   * load all files in <name> according to the regexp '\\.so'
   */
  Directory directory(name, Directory::alpha, "\\.so");
  Logger::log(Logger::loader) << "ServerImpl: scanning plugin dir " << name << endl;
  for (Directory::iterator i = directory.begin(); i != directory.end(); i++)
    {
      Plugin<KitFactory> *plugin = new Plugin<KitFactory>((*i)->longName());
      /*
       * if this is not a plugin, skip over it
       */
      if (!*plugin)
	{
	  cout << (*i)->name() << " not loadable " << plugin->error() << endl;
	  delete plugin;
	  continue;
	}
      factories.insert(fmap_t::value_type((*plugin)->type(), plugin));
      Logger::log(Logger::loader) << "ServerImpl: loaded factory for " << (*plugin)->type() << " from " << (*i)->name() << endl;
    }
}

void ServerImpl::clear()
//. hope you know what you are doing if you call this...
{
  MutexGuard guard(mutex);
  for (fmap_t::iterator i = factories.begin(); i != factories.end(); i++) delete (*i).second;
  factories.erase(factories.begin(), factories.end());
}

ServerImpl::FactoryList ServerImpl::list()
{
  FactoryList fl;
  for (fmap_t::iterator i = factories.begin(); i != factories.end(); ++i)
    fl.insert(FactoryList::value_type((*i).first, (*(*i).second)->properties()));
  return fl;  
}

void ServerImpl::start()
{
  thread.start();
}

KitImpl *ServerImpl::create(const char *type, const Kit::PropertySeq &properties, PortableServer::POA_ptr poa)
{
  Trace trace("ServerImpl::create");
  fmap_t::iterator f1 = factories.lower_bound(type), f2 = factories.upper_bound(type);
  for (fmap_t::iterator i = f1; i != f2; i++)
    if ((*(*i).second)->supports(properties))
      return (*(*i).second)->create(properties, poa);
  return 0;
}

void *ServerImpl::run(void *X)
{
  ServerImpl *server = reinterpret_cast<ServerImpl *>(X);
  while (true)
    {
      Thread::delay(1000);
      server->ping();
    }
  return 0;
}

