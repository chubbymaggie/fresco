#ifndef _CommandKit_idl
#define _CommandKit_idl

//
// $Id$
//
// This source file is a part of the Berlin Project.
// Copyright (C) 1998 Graydon Hoare <graydon@pobox.com> 
// http://www.berlin-consortium.org
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU Library General Public License
// as published by the Free Software Foundation; either version 2 of
// the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU Library General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
//

interface Command;

#include "Message.idl"
#include "Cloneable.idl"
#include "Text.idl"
#include "BoundedValue.idl"

// commands are anonymous encapsulated actions. 
// you never know what they'll do.
interface Command : Cloneable {	
    void execute(in Message args);
};

// this is a listener which has configurable behaviour based on the
// Message types it receives
interface Reactor : MessageListener {
  void bind(in CORBA::TypeCode ty, in Command c);
  void unbind(in CORBA::TypeCode ty, in Command c);
  attribute boolean active;
};

// this is just a helper to make the sequence-initialization below a
// little simpler.
struct ReactorBinding {
    CORBA::TypeCode ty;
    Command cmd;
};

typedef sequence<ReactorBinding> ReactorBindingList;

/** the command kit is a collection of strategy objects. they form the
    basis of any control protocol between widgets and subjects. The
    kit also encapsulates the constructors for command dispatchers
    (a.k.a. reactors), which you can think of as threading strategies
    if that suits you. */

interface CommandKit : Cloneable {

    // this usually results in a reactor with its own thread for
    // processing Messages, so when you send it a Message the call
    // returns in constant time
    Reactor asyncReactor(in ReactorBindingList initialBindings);

    // whereas this results in a reactor which consumes the calling
    // thread during Message receipt
    Reactor syncReactor(in ReactorBindingList initialBindings);

    Command adjustBoundedValue(in BoundedValue bv);


    Command sendMessage(in Message msgToSend, in MessageListener recipient);
    Command forwardMessage(in MessageListener recipient);
    Command forwardByGeometry(in MessageListener recipient, in Graphic geom);
    Command executeAfterCompleteClick(in Command otherCmd, 
				      in Graphic regionToWatch, 
				      in unsigned long buttonNumber);
    // more commands to follow in here

};

#endif
