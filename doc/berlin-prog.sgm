
  <chapter ID="programming-chapter">
    <title>Programming the Display Server</title>
    
    <abstract>
    <para>This chapter describes the ideas (and interfaces) which play
    key roles in the berlin display server, and gives an overview of
    their use in typical scenarios. The actual API is available in
    other places (including the source tree :). This section is
    intended to give you an idea how it all "fits together".</para>
    </abstract>
 
    <sect1 ID="graphics">
      <title>Graphics</title> 
      
      <para>The <classname>Graphic</classname> interface is
      implemented by any object which is to appear on the screen or
      other display device; in other words, any object which is
      subject to the layout and rendering processes. Graphics are
      composed within one another in a directed, acyclic graph
      (DAG). Some examples of Graphics are: glyphs (anti-aliased
      images of text characters), pixmaps, bezier curves, polygons,
      windows, buttons, scroll bars, menus, and alignment, flow and
      grouping boxes such as those found in TeX. 
</para>

      <para>Graphics in the DAG are connected together by Edges. An
      Edge is an encapsulated relationship between a parent graphic
      and a child. The DAG of all Graphics and Edges in a Berlin
      server is commonly called the Scene Graph. Some examples of the
      containment relationship are: glyphs within a word, words within
      a line, lines within a page, entries within a menu, buttons
      within a toolbar, polygons within a structured graphics editor,
      images within a web page, windows within the screen. The same
      type of Edge interface is used to represent each such
      containment relationship.</para>

      <para>The main operations on the scene graph are layout &amp;
      drawing, and delivering events (picking). These operations are
      encapsulated into visitor-pattern objects called Traversals. A
      DrawTraversal traverses the scene graph laying graphics out and
      then drawing them using its DrawingKit.


      <para>A <classname>graphic</classname> is any thing which can
	be displayed visually. Thus <classname>graphic</classname> is
	one of the simplest and most widespread types in the berlin
	code. All <classname>graphic</classname>s support a single method, 

<funcsynopsis>
	  <funcprototype>
	    <funcdef>
<function>draw</function>
                    </funcdef>
	    <void>
	  </funcprototype>
	</funcsynopsis>

               which causes them to <emphasis>prepare</emphasis>
               themselves to be shown on a display device. The draw
               method does <emphasis>not</emphasis> actually display
               the <classname>graphic</classname> on the screen. The
               <classname>graphic</classname> interface has no
               explicit knowledge of what sort of rendering system is
               used to actually produce a visual image on a display
               device. In the case of the berlin reference
               implementation, an OpenGL display list is generated,
               which is then transfered by other means to the
               screen. It is very important to realize that calling
               draw does not necessarily cause anything visible to
               occur at all. Furthermore, the draw method may operate
               asynchronously, so it is not guaranteed that an object
               has actually prepared itself when the draw method
               returns. In order to guarantee that, one must take
               other measures, such as registering oneself as an
               observer and waiting for an update to come from the
               object.</para>

      <para>This may sound somewhat strange, as it sounds as though
      maintaining a consistent image on the screen would be
      exceedingly difficult. In fact, due to the presence of the
      subject/observer pattern throughout the system, it is quite
      stable and works. In general, a damaged (changed) region
      finishes redrawing <emphasis>before</emphasis> notifying any of
      its observers that it has changed state. In this case, redrawing
      literally means recompiling a small display-list in OpenGL -- the
      display-list which encompasses the graphical representation of its
      state. The observers, which in general include the composite
      graphic which contains the damaged region, react to the
      notification of a subject's change of state by recompiling their
      own display-lists, and (when finished) notifying their own
      observers. This proceeds out until the main terminal is
      notified, and the screen refreshes. Thus, damaged regions of the
      screen <emphasis>propagate themselves</emphasis> out to the
      display. There is no need to send "expose events" or anything,
      as the concept of the composition of graphical state by means of
      sub-graphics is explicit at all levels of the API.</para>

      </sect1>
    
    <sect1 ID="composites">
      <title>Composite Graphics</title>

      <para>With a little thought, it should be clear that a lot of
      graphics (things on the screen) are logically well-represented
      by a recursive nesting of sub-graphics, each in turn composed of
      perhaps some number of sub-sub-graphics, etc. There must
      eventually be a bunch of leaf-node graphics in this tree, but
      there are also a sizeable number of interior nodes, such as
      panning/scrolling windows, lines in a buffer, menus in a
      menu-bar, etc. These sorts of graphics are a distinguished
      subclass of <classname>graphic</classname> called
      <classname>composite</classname>. They allow you to add, remove,
      rearrange, and traverse the child graphics. They observe their
      children, and when their children change, they change. They
      often (though not always) clip their children's display area to
      a bounding box or region. They also usually present a local
      coordinate space in which their children can draw. This is very
      easily accomplished in OpenGL, where one can arbitrarily push
      and pop matrices from a stack of composed linear
      transformations on the current drawing space. In such a case,
      moving a parent has the visual effect of moving all of its
      children along with it, as the coordinate spaces are composed
      one within the other. Likewise stretching, tilting, rotating,
      panning, etc. will, unless otherwise specified, effect all
      children of a composite.</para>

    </sect1>

      <sect1 ID="reactors">
	<title>Reactors</title> 

	<para>A <classname>reactor</classname> is a common pattern in
	a software system. Many systems have reactors they don't call
	reactors, they call them dispatch tables. The concept is very
	simple. There is a table stored within some software module
	which relates incoming requests to actions to be taken. The
	actions have an anonymous signature, so they can be rearranged
	or reassigned. The point of a <classname>reactor</classname>
	is that it serves as a dynamically reconfigurable part of an
	otherwise statically-typed program. It serves as the key
	flexibility abstraction.</para>

	<para><Classname>Reactor</Classname>s are implemented in
	berlin as Corba interfaces. The "incoming requests" are of
	type <classname>Any</classname> which is an inspectable,
	unspecified type. The <Classname>Any</Classname>'s are
	inspected and their <classname>typecode</classname>s are
	matched against other <classname>typecode</classname>s stored
	in the <classname>reactor</classname>, and a set of selections
	is made based on the <classname>typecode</classname>s which
	match.
	</para>

	<para> Since there is no such thing as a function pointer in
	IDL, it is necessary to promote the action part of a dispatch
	table to full interface status. Thus we have instances of
	interface <classname>command</classname>, which must support a
	single method:

<funcsynopsis>
	    <funcprototype>
	    <funcdef>
<function>execute</function>
                    </funcdef>
	    <paramdef><parameter>Any a</parameter></paramdef>
	  </funcprototype>
	</funcsynopsis>

              The <Classname>Any</Classname>, which may contain a
              great deal of important information, is provided as a
              parameter to the <classname>command</classname> to do
              with as it pleases. An application may bind multiple
              <classname>command</classname>s to multiple
              <classname>typecode</classname>s, in order to customize
              the behavior of a
              <classname>reactor</classname>.</para>
      </sect1>

    <sect1 ID="commands">
      <title>Commands</title> 

      <para>A <classname>command</classname>, as mentioned in the
      <Classname>reactor</Classname> section, is a named, encapsulated
      function supporting at least one anonymous interface which can
      cause it to "execute". The entire purpose of
      <classname>command</classname>s is that they can be placed in
      <classname>reactor</classname>s, and the
      <classname>reactor</classname> can be configured to execute them
      on any type of incoming request without violating the
      compile-time type safety of C++. Each
      <classname>command</classname> can support additional methods
      aside from execution; such methods can alter the state of each
      individual instance of a <classname>command</classname>,
      modifying its behavior and thus simplifying the call-back
      interface. All the <classname>reactor</classname> will do is
      trigger the <classname>command</classname> in its current state
      -- it is up to the application programmer to put the command in
      a useful state before any such triggerings occur.</para>

      <informalexample>
	<para>As an example of the use of commands, consider the
	"message-passing" system in berlin. Any
	<classname>reactor</classname> must receive its incoming
	requests / messages from somewhere, and the general mechanism
	for doing so is to bind an instance of a
	<classname>sendMessageCommand</classname> or a
	<classname>forwardMessageCommand</classname> to another,
	pre-existing <classname>reactor</classname>. There is always
	at least 1 reactor in a berlin server: the terminal widget,
	which is in control of the console. 
	<classname>SendMessageComand</classname> can be configured to
	send some particular thing to some particular
	<classname>reactor</classname>  upon
	execution, using the
	<function>reactor.accept(Any a)</function> method. If you want to send some
	<symbol>fooMessage</symbol> to some
	<symbol>barReactor</symbol>, every time a key is pressed, you
	could create a <classname>SendMessageCommand</classname>
	<symbol>fizz</symbol>, and call
	<function>fizz.target(fooReactor)</function>, followed by
	<function>fizz.theMessage(fooMessage)</function>, and then
	<function>terminal.bind(fizz, _tc_keyEvent)</function>.  This
	would instruct the terminal widget, which is itself just
	another glorified reactor, to match all keyEvent
	<classname>typecode</classname> <classname>Any</classname>s
	against <symbol>fizz</symbol>. When it receives a keyEvent,
	which it polls the console for, it would match against
	<symbol>fizz</symbol>'s binding, and call
	<function>command.execute(Any a)</function> on
	<symbol>fizz</symbol>. Then your <symbol>fooMessage</symbol>
	would be sent.</para>
      </informalExample>
    </sect1>

    <sect1 ID="events">
      <title>Events</title> 

      <para>Events are reasonably important in a GUI. They are the
      data structures generated rapidly by users (and programs) as
      they interact with the display server. Events cause basically
      everything to happen. If the system has no events in it, then it
      is most likely idle. Because event is such a broad term, it is
      difficult to know exactly what sorts of event will come to
      exist, how they should be dealt with, filtered, passed, ignored,
      stored, replayed, etc. Every user seems to like their computer
      to respond in a slightly different manner, and users themselves
      vary in the sorts of events they generate. Programs vary in how
      fast they can respond to events and whether they are interested
      or not in even being informed of events. Thus we have a very
      general, asynchronous mechanism for processing events (and
      anything else you want to pass around between asynchronous
      queues) called <classname>reactors</classname>. See that section
      for details on how they work.
      </para>

      <para>The events defined in Warsaw are small IDL structs
      representing raw data we read out of the GGI visual. These
      correspond to pointer movement information, pointer click and
      release events, key press, repeat, and release events (and their
      corresponding unicode character values). GGI obtains the events
      from the console device, the X bridge, or whatever subsystem it
      happens to be running on. It is not the concern of berlin to
      deal with events below the GGI layer. Once inside berlin, the
      events are passed and filtered by
      <classname>commands</classname> in the various
      <classname>reactors</classname>. Since windows are themselves
      reactors, the top-level widget usually just calls commands which
      check focus and geometric information in the events and forward
      the interesting ones to the reactors of the individual
      windows. If a window or sub-widget (there is no difference) is
      not interested in an event, it will not have explicitly asked to
      be sent copies of it, and no traffic occurs at all. This
      behavior is completely configurable however, simply by writing
      (and binding) new commands to the terminal widget or some
      sub-widgets. It is not at all hard to create commands which, for
      instance, expand keystrokes into macros of other events, replay
      previous events, interpolate and re-sample events to lie below a
      given frequency threshold, translate events between types,
      display a debugging log of all events passed through them, etc.
    </sect1>

    <sect1 ID="widgets">
      <title>Widgets</title> 
      <para>A widget is a composite graphic and a reactor. No more, no
      less. It was named "widget" because subclasses of it play the
      same role in berlin as other widgets in other toolkits -- they
      are reusable graphical components with configurable behavior
      and a reasonably clear, common means of operation by a user. If
      a graphic does not need to asynchronously process messages or
      events of any sort, it most likely does not need to be a
      widget. On the other hand, many things which have separate
      concepts in other windowing systems (windows, the controlling
      terminal, etc) are implemented as special-cases of widgets in
      berlin. This means that, in general, the entire server can be
      run recursively inside a window on the screen, which should
      simplify testing and remote administration /
      troubleshooting. The terminal, since it is a widget and by
      extension just another Corba lifecycle object, can be moved all
      at once between 2 different hosts, just as any window or
      sub-widget in berlin can be migrated between hosts.</para>
    </sect1>

    <sect1 ID="subjobs">
      <title>Subject/Observer</title> 

      <para>The Subject/Observer software pattern is extremely common
      in GUI systems. It is called Subject/Observer in Java, but if
      you have used anything employing the Model/View framework
      before, you will know how this works. Basically a selected
      portion of objects inherit the interface of subjects, which can
      be observed by any object inheriting the interface of an
      observer. These are not necessarily disjoint types of objects,
      they're just convenient interfaces. The Functionality is very
      simple: observers have a list of things they are observing, and
      subjects have a list of observers which are observing
      them. Whenever a subject changes state in any externally visible
      way, it calls <function>this->notify_observers()</function>,
      which iterates over all the observers observing the subject and
      for each of them, calls
      <function>observer->update(this)</function>. This informs the
      observers that the subject has changed, in some way that they
      <emphasis>might</emphasis> be interested in. It is at the
      discretion of an observer what it chooses to do with the update
      notification. Usually it will verify its view of the subject,
      possibly extracting information from the subject about its
      current state. The Subject/Observer pattern merely standardizes
      the mechanism by which this information is conveyed.
</para>

      <para>It is not necessary for the <function>update</function>
      method to be implemented entirely in synchronous terms. In fact,
      it would be unduly burdening the subject's thread if it had to
      wait for each of the observers to finish updating themselves in
      order to proceed. Thus, it is advantageous in certain situations
      to implement <function>update</function> in terms of sending a
      <className>subjectChangedMessage</classname> to the observer's
      thread, if the observer happens to be in a separate
      thread. Threads are discussed in more detail shortly</para>
    </sect1>


  <!-- include the fabulously well-written threading document  :) -->
  &berlin-prog-thread;

      <sect1 ID="factories">
	<title>Factories</title>

      <para>A factory is an easily locatable object which is
      responsible for creating new objects in response to some
      requests. In the berlin display server, there is an
      implementation of a Corba <classname>GenericFactory</classname>,
      which dynamically loads pluggable objects and creates instances
      of them in response to Corba requests. The objects created by
      the <classname>GenericFactory</classname> reside in the address
      space of the display server, but Corba references to them are
      sent to clients once the objects have been created and
      activated.</para>

      <para>The Orb we are currently using supports Corba Lifecycle
      service, which is a common protocol for creating, destroying and
      moving (by copying and redirecting) objects. The GenericFactory
      written for berlin implements a part of the Lifecycle
      specification, as does the
      <classname>LifeCycleObject</classname> and
      <classname>omniLC</classname> code, from which most of our
      runtime objects are derived. Thus it is possible to move widgets
      from one berlin display server to another, or to replace running
      widgets on a single display server (called "hot swap") without
      interrupting the clients at all.</para>

      </sect1>


      <sect1 ID="sessions">
	<title>Sessions</title>
      
      <para>A <classname>session</classname> is a logical collection
	of all the allocated resources a given client uses when
	connecting to the display server. The server maintains a
	collection of sessions in an object called a
	<classname>sessionManager</classname>, which is responsible
	for granting new sessions to connecting clients. A client is
	represented in the system by the
	<classname>principal</classname> interface, which the session
	may query from time to time to determine its security rights
	and identity. When a client is no longer reachable, a session
	destroys all the resources it is in charge of, and then
	destroys itself. Sessions occasionally ping clients to check
	to see if they are still alive. </para>

      <para>This implies that principals are in the client address
      space, which indeed (if you look at berlin clients) they
      are. Not only do principals represent the reachability of a
      given client, they are also the place in which all security
      mechanisms will be implemented. Obviously it is unacceptable to
      transmit ones security credentials over the wire to a display
      server -- rather, the client must respond intelligently to a
      given challenge with appropriate credentials. This allows berlin
      to use asymmetric security systems like public key cryptography.
      </para>
    </sect1>

    &berlin-prog-text;
    &berlin-prog-corba;
    &berlin-prog-opengl;

  </chapter>

    <!--
     Local Variables:
     mode: sgml
     sgml-doctype: "berlin-man.sgm"
     sgml-parent-document: ("berlin-man.sgm" "book" "chapter")
     End:
     -->
